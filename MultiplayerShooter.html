<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Shooter Game</title>
    <link rel="stylesheet" href="project.css">
    <link rel="icon" type="image/png" href="./assets/favicon.png">
    <style>
        .video-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .video-indicator:before {
            content: '';
            width: 0;
            height: 0;
            border-top: 8px solid transparent;
            border-left: 12px solid white;
            border-bottom: 8px solid transparent;
            margin-left: 3px; /* Slight offset for visual balance */
        }
        
        .thumbnail {
            position: relative;
            width: 100px;
            height: 56px;
            cursor: pointer;
            background-size: cover;
            background-position: center;
            transition: opacity 0.3s;
            border: 2px solid transparent;
        }
        
        .thumbnail.active {
            border-color: #4a6cf7;
        }
        
        .main-media-display {
            position: relative;
            width: 100%;
            max-width: 960px;
            margin: 0 auto;
            overflow: hidden;
        }
        
        .main-media-display video, .main-media-display img {
            width: 100%;
            height: auto;
            display: block;
            transition: opacity 0.3s;
        }
        
        .thumbnail-container {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }
    </style>
</head>
<body>
  <div id="projects" style="height: 100%;">
    <p class="go_back_text">
        <a href="index.html#projects">< Back to Portfolio</a>
    </p>
    <h1 class="title">Multiplayer Shooter Game</h1>
</div>
      <!-- Media Gallery -->
      <div class="media-gallery" style="margin-bottom: 2.5rem;">
          <div class="main-media-display" style="border: 2px solid #293341;">
              <video class="video" width="960" height="540" controls autoplay muted loop data-type="video">
                  <source src="./assets/MultiplayerShooterDemo.webm" type="video/webm">
                  Your browser does not support the video tag.
              </video>
          </div>
          <div class="thumbnail-container">
              <div class="thumbnail active" data-src="./assets/MultiplayerShooterDemo.webm" data-type="video">
                  <span class="video-indicator"></span>
              </div>
              <div class="thumbnail" data-src="./assets/ShooterAmmo.png" data-type="image">
                  <img src="./assets/ShooterAmmo.png" alt="Ammunition" width="100" height="56">
              </div>
              <div class="thumbnail" data-src="./assets/ShooterWeapons.png" data-type="image">
                  <img src="./assets/ShooterWeapons.png" alt="Weapons" width="100" height="56">
              </div>
              <div class="thumbnail" data-src="./assets/ShooterPowerups.png" data-type="image">
                  <img src="./assets/ShooterPowerups.png" alt="Powerups" width="100" height="56">
              </div>
          </div>
      </div>

      <div class="btn-container">
        <button 
            class="btn btn-color-2 btn-switch" 
            onclick="window.open('https://github.com/AlexKougentakos/UE5-MultiplayerShooter/releases/download/v1.0.1/Multiplayer-Shooter-Game-v1.0.1.zip')">
          <span class="btn-content">
            <img src="./assets/download-white.png" alt="Icon" class="btn-icon default-icon">
            Download Build
          </span>
        </button>
        <button 
            class="btn btn-color-1" 
            onclick="window.open('https://github.com/AlexKougentakos/UE5-MultiplayerShooter', '_blank')">
          <span class="btn-content">
            <img src="./assets/github.png" alt="Icon" class="btn-icon">
            Github Link
          </span>
        </button>
      </div>
      
      <section>
        <div class="section-content">
            <p class="title2-header">What I have</p>
            <h1 class="title2">Learned</h1>

            <p class="title3">Networking In Unreal Engine 5</p>
            <div class="paragraph-container">
                <img src="./assets/NetworkingImage.png" alt="Image" class="image-container image-left">
                <p class="paragraph-left">
                    The primary goal of developing this game was to deepen my understanding of multiplayer functionality in 
                    Unreal Engine 5. Throughout the process, I gained valuable insights into replication, the listen server
                     model, and server-client architecture. One of the most intriguing challenges was determining when to
                      use replication, whether to rely on RPCs or replicated variables, and how to optimize network traffic. 
                      Although I never intended to release this game, I aimed to maintain a server-authoritative architecture,
                       keeping the client as simple as possible.
                </p>
            </div>

            <p class="title3">Client Side Prediction</p>
            <div class="paragraph-container">
                <p class="paragraph-center">
                    Another interesting concept I learned about was client side prediction. 
                    This technique enhances the game's responsiveness by allowing the client to predict the outcome of the
                     player's actions, then adjusting if needed when the server responds. This approach is particularly
                      effective for actions that must feel immediate to the player without compromising server authority.
                       A practical example is weapon reloading, where the HUD updates instantly, correcting if necessary
                        when the server confirms the action.
                </p>
            </div>

            <p class="title3">Server Side Rewind</p>
            <div class="paragraph-container">
                <p class="paragraph-right">
                    Perhaps the most challenging yet fascinating concept I explored was server-side rewind (SSR),
                     a lag compensation technique that improves both responsiveness and fairness in the game.
                      I implemented SSR in the shooting mechanics. When a player fires a shot, if SSR is enabled,
                       the server rewinds the player's position to the moment of the shot and simulates the event 
                       from its perspective. This allows the server to accurately determine whether the shot was a hit 
                       or a miss before relaying the result back to the client.
                </p>
                <img src="./assets/SSR_Image.png" alt="Image" class="image-container image-right">
            </div>

            <p class="title3">Animation Blending</p>
            <div class="paragraph-container">
                <img src="./assets/AnimGraph.png" alt="Image" class="image-container image-left">
                <p class="paragraph-left">
                    Since I could only use animations that I got from the Unreal Engine Marketplace, 
                    I had to make the most out of them. This led to a deeper understanding of the animation state machine and how to blend animations together.
                    I also learned how to replicate animations effectively, using the already replicated player
                     model, since the animation instance itself isn't replicated by default.
                </p>
            </div>
        </div>
    </section>

    <section>
        <div class="section-content">
            <p class="title2-header">What I would</p>
            <h1 class="title2">Like to Add</h1>

            <p class="title3">Anti Cheat Detection</p>
            <div class="paragraph-container">
                <p class="paragraph-center">
                    A fascinating area I'd like to explore further is anti-cheat detection. 
                    My first step would be ensuring all critical game logic is server-authoritative, 
                    as currently, some client-side authority could be exploited through memory address manipulation. 
                    For instance, the fire delay for weapons is currently managed client-side, which could be vulnerable.
                </p>
            </div>

            <p class="title3">Networking Improvements</p>
            <div class="paragraph-container">
                <p class="paragraph-center">
                    I would like to add a number of improvements regarding the networking.
                    One idea is implementing a lobby system that allows players to browse available lobbies,
                     view player counts, ping, game modes, and maps before joining,
                    instead of being randomly assigned to a game

                    <br/>
                    <br/>

                    Another area of interest is developing a friend system, which would involve creating
                    an account system, potentially integrating the Steam APIâ€”a tool I haven't yet explored.
                </p>
            </div>

            <p class="title3">More Game Modes</p>
            <div class="paragraph-container">
                <p class="paragraph-center">
                    Since the project's main focus was networking, I didn't dedicate much time to developing the actual gameplay.
                     However, if I had the opportunity to continue, I would implement various game modes like team deathmatch,
                      capture the flag, king of the hill, and push the payload to enhance the gaming experience.
                </p>
            </div>
        </div>
    </section>

    <script>
      // Function to generate video thumbnails
      async function generateVideoThumbnail(thumbnailDiv) {
        const videoSrc = thumbnailDiv.dataset.src;
        if (!videoSrc) return;

        thumbnailDiv.classList.add('loading'); // Show loading indicator

        try {
          const video = document.createElement('video');
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');

          video.src = videoSrc;
          video.muted = true;
          video.playsInline = true;
          video.preload = 'metadata';

          await new Promise((resolve, reject) => {
            video.onloadedmetadata = () => {
              video.currentTime = 0.1; // Seek slightly into the video
            };
            video.onseeked = async () => {
              // Set canvas dimensions
              canvas.width = video.videoWidth;
              canvas.height = video.videoHeight;
              // Draw the video frame to the canvas
              context.drawImage(video, 0, 0, canvas.width, canvas.height);
              // Set canvas content as background image
              thumbnailDiv.style.backgroundImage = `url(${canvas.toDataURL('image/jpeg')})`;
              resolve();
            };
            video.onerror = (e) => {
                console.error('Error loading video for thumbnail:', videoSrc, e);
                reject(e);
            }
            // Start loading the video
            video.load(); 
          });

        } catch (error) {
          console.error("Error generating thumbnail for", videoSrc, error);
          // Optionally set a fallback background
          thumbnailDiv.style.backgroundColor = '#555'; // Indicate error
        } finally {
          thumbnailDiv.classList.remove('loading'); // Hide loading indicator
        }
      }

      document.addEventListener('DOMContentLoaded', () => {
        const mainMediaDisplay = document.querySelector('.main-media-display');
        const thumbnails = document.querySelectorAll('.thumbnail');

        // Generate thumbnails for video types and add video indicators
        thumbnails.forEach(thumbnail => {
          if (thumbnail.dataset.type === 'video') {
            generateVideoThumbnail(thumbnail);
            
            // Add video indicator if not already present
            if (!thumbnail.querySelector('.video-indicator')) {
              const indicator = document.createElement('span');
              indicator.className = 'video-indicator';
              thumbnail.appendChild(indicator);
            }
          }
        });

        // Click handler for thumbnails
        thumbnails.forEach(thumbnail => {
          thumbnail.addEventListener('click', () => {
            const activeThumbnail = document.querySelector('.thumbnail.active');
            if (thumbnail === activeThumbnail) return;

            activeThumbnail?.classList.remove('active');
            thumbnail.classList.add('active');

            const src = thumbnail.dataset.src;
            const type = thumbnail.dataset.type;
            const currentMediaElement = mainMediaDisplay.querySelector('video, img');

            let newMediaElement;
            if (type === 'video') {
              newMediaElement = document.createElement('video');
              newMediaElement.src = src;
              newMediaElement.controls = true;
              newMediaElement.autoplay = true;
              newMediaElement.muted = true;
              newMediaElement.loop = true;
              newMediaElement.dataset.type = 'video';
              newMediaElement.width = 960;
              newMediaElement.height = 540;
            } else if (type === 'image') {
              newMediaElement = document.createElement('img');
              newMediaElement.src = src;
              newMediaElement.alt = 'Project Media';
              newMediaElement.dataset.type = 'image';
            }

            if (newMediaElement) {
              newMediaElement.style.opacity = '0';
              mainMediaDisplay.appendChild(newMediaElement);

              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    if (currentMediaElement) {
                        currentMediaElement.style.opacity = '0';
                        setTimeout(() => {
                          currentMediaElement.remove();
                        }, 300);
                    }
                    newMediaElement.style.opacity = '1';
                });
              });
            }
          });
        });
      });
    </script>
</body>
</html>